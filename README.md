# Kamailio Playground

## SIP

### Diferencia entre sesión, transacción y dialogo

#### Transacción

Una transacción consiste en un `request`, respuestas de código `1xx`, mensajes de `ACK` y una respuesta final de código `2xx`, `3xx`, `4xx`, `5xx`, o `6xx`. _No se incluye el `ACK` asociado a respuestas de código `2xx`. Básicamente, un request más un response.

Por ejemplo:

```txt
SIP peer A sends an INVITE to SIP peer B
SIP peer B returns a response of 100 Trying
SIP peer B returns a response of 200 OK
```

> In the previous SIP RFC2543 the transaction identifier was calculated as hash of all important message header fields (that included To, From, Request-URI and CSeq). This proved to be very slow and complex, during interoperability tests such transaction identifiers used to be a common source of problems.
>
> In the new RFC3261 the way of calculating transaction identifiers was completely changed. Instead of complicated hashing of important header fields a SIP message now includes the identifier directly. Branch parameter of Via header fields contains directly the transaction identifier. This is significant simplification, but there still exist old implementations that don't support the new way of calculating of transaction identifier so even new implementations have to support the old way. They must be backwards compatible.
>
> **[http://www.kamailio.org/docs/tutorials/sip-introduction/](http://www.kamailio.org/docs/tutorials/sip-introduction/)**

#### Dialogos

Un dialogo es una serie de transacciones entre dos peer SIP. El proposito de un dialogo es el establecimiento de una sesión (SIP = Session Initiation Protocol.) Como pueden existir múltiples dialogos entre dos peer SIP, se identifica a cada uno de ello por los encabezados: `To`, `From`, y `Call-ID` (se utiliza el parámetro `tag` en los encabezados `To` y `From` para mantener la consistencia). Por ejemplo:

```txt
SIP peer A invites SIP peer B to a session and suggests a certain codec, but does not include authentication and so is rejected
SIP peer A again invites SIP peer B to a session, this time supplying authentication, and the invitation is accepted
SIP peer B sends an invitation to change the codec used, and it is accepted
SIP peer A ends the session
```

> We have shown what transactions are, that one transaction includes INVITE and it's responses and another transaction includes BYE and it responses when a session is being torn down. But we feel that those two transactions should be somehow related--both of them belong to the same dialog. A dialog represents a peer-to-peer SIP relationship between two user agents. A dialog persists for some time and it is very important concept for user agents. Dialogs facilitate proper sequencing and routing of messages between SIP endpoints.
> 
> Dialogs are identified using Call-ID, From tag, and To tag. Messages that have these three identifiers same belong to the same dialog. We have shown that CSeq header field is used to order messages, in fact it is used to order messages within a dialog. The number must be monotonically increased for each message sent within a dialog otherwise the peer will handle it as out of order request or retransmission. In fact, the CSeq number identifies a transaction within a dialog because we have said that requests and associated responses are called transaction. This means that only one transaction in each direction can be active within a dialog. One could also say that a dialog is a sequence of transactions.
> 
> Call-ID is so called call identifier. It must be a unique string that identifies a call. A call consists of one or more dialogs. Multiple user agents may respond to a request when a proxy along the path forks the request. Each user agent that sends a 2xx establishes a separate dialog with the caller. All such dialogs are part of the same call and have the same Call-ID.
>
> From tag is generated by the caller and it uniquely identifies the dialog in the caller's user agent.
> 
> To tag is generated by a callee and it uniquely identifies, just like From tag, the dialog in the callee's user agent.
> 
> This hierarchical dialog identifier is necessary because a single call invitation can create several dialogs and caller must be able to distinguish them.
> **[http://www.kamailio.org/docs/tutorials/sip-introduction/](http://www.kamailio.org/docs/tutorials/sip-introduction/)**

#### Sesiones

Una sesión es un stream de contenido, fluyendo entre dos peers, usualmente consistiendo de mensajes RTP. 

### Record Routing

Todos los request involucrados en un dialogo son enviados por defecto entre los UA involucrados. Solo los requests por fuera del dialog atraviesan los SIP Proxies. Existen situaciones en donde el SIP proxy debe seguir en el camino de los mensajes. Por ejemplo, proxis que controlan un NAT box o proxies haciendo accounting (necesitan quedar en el camino de los mensajes de `BYE`).

Los mecanismos que permiten este comportamiento son identificados bajo el nombre de _record routing_. Los proxies que aplican estos mecanismos agregan a los mensajes SIP un encabezado `Record-Route`. Estos encabezados hacen que todos los mensajes del dialogo atraviesen los SIP proxies.

[BYE Messges Flow (with and without Record Routing)](http://www.kamailio.org/docs/tutorials/sip-introduction/figures/bye.png)

### Strict vs Loose Routing

De acuerdo a la RFC2543 _record routing_ rescribe el encabezado `Request-URI`, de manera de que tuviera siempre la URI del siguiente salto (que podía ser el siguiente proxy server que inserto el encabezado `Record-Route` o el UA de destino.) El problema es que esto obligaba el almacenado de el `Request-URI` original y el último `Route`. Esta forma de operar _record routing_ se identifica como **strict routing**. 

En la RFC3261 se específico otro modo de funcionamiento llamado **loose routing**. Ahora el `Request-URI` no se sobreescribe, siempre contiene la URI del UA de destino. Si existe algún encabezado `Route` en el mensaje, entonces el mensaje es enviado a la URI indicada por el primer encabezado `Route` encontrado en el mensaje. Por lo tanto, el `Request-URI` no necesariamente indica el siguiente salto del mensaje. Este comportamiento es más parecido al enrutamiento de paquetes IP.

Hacer _loose routing_ compatible hacia atras con _strict routing_ es bastante complejo, y agrega un gran overhead al proceso.

## Funcionamiento de la configuración de Kamailio

Kamailio utiliza un lenguajde de scripting para su configuración, usualmente encontrado en la ubicación `/etc/kamailio/kamailio.cfg`. Este lenguaje de scripting llamado `native scripting` fue desarrollado específicamente para Kamailio entre 2001-2002.

La configuración esta compuesta por las siguientes secciones:

1. **Global Parameters**: Parámetros de configuración global.
2. **Loading Modules**: Carga de módulos a utilizar.
3. **Module Parameters**: Configuración de módulos a través de parámetros.
4. **Routing Blocks**: Bloques de configuración para gestionar los mensajes y las respuestas.

Esta configuración es leída solo una vez al momento que se inicia el proceso de Kamailio. Luego se compila, y se almacena en memoria. Una vez cargada, cada mensaje o respuesta recibida será tratado en base a esta configuración.

## Kamailio Proxy en Modo Bridge

En este escenario, se configura el kamailio en un servidor con dos interfaces de red. Una que mira hacia una DMZ (10.0.1.0/24), y otra que mira hacia la red interna (10.0.2.0/24). La interfaz del Kamailio esta públicada en Internet con la IP 1.1.1.1. 

![Kamailio en modo bridge](images/kamailio_bridge_mode.png)

Toda la gestión de las sesiones es manejada por la PBX, el Kamailio solamente oficia de Proxy. La configuración mínima para correr el Kamailio en esta configuración es la siguiente:

```kamailio
####### Global Parameters #########
# Listen LAN
listen = tcp:10.0.2.100:5060

# Listen WAN
listen = tcp:10.0.1.100:5060
listen = udp:10.0.1.100:5060

# TCP
disable_tcp = no
tcp_async = yes
tcp_children = 2

# Alias
#alias="kamailio.example.com:5060"

####### Module Load   ########
loadmodule "tm.so"
loadmodule "tmx.so"
loadmodule "rr.so"
loadmodule "pv.so"
loadmodule "textops.so"
loadmodule "xlog.so"

loadmodule "rtpproxy.so"

####### Module Configuration #######
modparam("rtpproxy", "rtpproxy_sock", "udp:127.0.0.1:7722")

####### Routing Logic ########

/* Main SIP request routing logic
 * - processing of any incoming SIP request starts with this route
 * - note: this is the same as route { ... } */
request_route {
	rtpproxy_manage('iewc');

  t_relay("10.0.2.200", "5060");
}

onreply_route{
	if (has_body("application/sdp")) {
		rtpproxy_manage("iewc");
	}
}
```

Básicamente, el Kamailio reenvía todos los mensajes que recibe a la PBX. Y luego, utiliza el módulo `rtpproxy` para gestionar el audio entre participantes.

Es importante mencionar que con esta conversación solo se esta manejando el caso de que los mensajes salga de un interno y vayan hacia la PSTN. Además, no funciona la llamada en espera ni la pausa. Para que esto funcione, es necesario agregar más detalles a la configuración.

### `rtpproxy`

Para que el módulo `rtpproxy` funcione, es necesario contar con un proceso de `rtpproxy` corriendo en algún servidor. En este ejemplo, el proceso se ejecuta en la misma maquina.

`rtpproxy` puede ser ejecutado en modo bridge, para esto, se puede correr el proceso con las siguientes opciones:

```bash
rtpproxy \
  -A 1.1.1.1/10.0.2.100 \
  -u rtpproxy rtpproxy \
  -l 10.0.1.100/10.0.2.100 \
  -m 10000 -M 20000 \
  -s udp:*:7722 \
  -d INFO
```

- `-A`: Indica las IP sobre las cuales esta públicado el servidor. Esta opción es útil para configurar interfaces públicadas en Internet. Cuando se colocan dos IPs separadas por una barra (`/`) indica que el `rtpproxy` debe trabajar en modo bridge.
- `-u`: Indica el usuario que se debe utilizar para correr el proceso.
- `-l`: Indica las IP sobre las cuales debe escuchar el `rtpproxy`. Cuando se colocan dos IPs separadas por una barra (`/`) indica que el `rtpproxy` debe trabajar en modo bridge.
- `-m`: Indica el rango inferior de puertos que debe utilizar el `rtproxy`.
- `-M`: Indica el rango superior de puertos que debe utilizar el `rtpproxy`.
- `-s`: Indica el socket en el que el `rtpproxy` escucha comandos de control.
- `-d`: Indica el modo de logs. En este caso `INFO`.

El Kamailio se comunicara con el proceso de `rtpproxy` a través del socket configurado con `-s`. Esta configuración se realiza modificando la variable `rtpproxy_sock` del módulo `rtpproxy`.

```kamailio
modparam("rtpproxy", "rtpproxy_sock", "udp:127.0.0.1:7722")
```

Dentro del módulo `rtpproxy` existe una función llamada `rtpproxy_manage` que se encarga de gestionar la interacción con el proceso de `rtpproxy`. Esta función, consume una serie de flags que modifican su comportamiento. En este caso:

```kamailio
rtpproxy_manage("iew");
```

> i, e - these flags specify the direction of the SIP message. These flags only make sense when rtpproxy is running in bridge mode. 'i' means internal network (LAN), 'e' means external network (WAN). 'i' corresponds to rtpproxy's first interface, 'e' corresponds to rtpproxy's second interface. You always have to specify two flags to define the incoming network and the outgoing network. For example, 'ie' should be used for SIP message received from the local interface and sent out on the external interface, and 'ei' vice versa. Other options are 'ii' and 'ee'. So, for example if a SIP requests is processed with 'ie' flags, the corresponding response must be processed with 'ie' flags.
> 
> c - flags to change the session-level SDP connection (c=) IP if media-description also includes connection information.
> 
>w - flags that for the UA from which message is received, support symmetric RTP must be forced.
>
> **[Documentación de `rtpproxy`](https://kamailio.org/docs/modules/5.3.x/modules/rtpproxy.html)**

- `ie`: Indica la dirección de los mensajes SIP cuando `rtpproxy` opera en modo bridge. `i` indica la red interna, y e indica la red externa. Siempre es necesario indicar los dos flags, lo que puede modificarse es el órden de los flags. Las combincaciones posibles on `ii`, `ee`, `ie`, e `ei`. `ie` indica que el mensaje es recibido por la interface local, y es enviado por la externa. Los mensajes procesado con un par de flags, deben ser procesados en la respuesta con el mismo par de flags.
- `c`: Indica que los campos `c=` del cuerpo SDP del mensaje SIP también deben ser modificados.
- `w`: Indica que se debe forzar el uso de RTP simetrico para el UA que envía el mensaje.

## `include_file` e `import_file`

Se utiliza para cargar contenido en la configuración previo a su parseo.

```kamailio
include_file "<path_to_file>"
```

El `path_to_file` puede ser relativo. Cada uno de estos archivos puede también referenciar a otros. Existe un límite en la profundidad de archivos referenciados de 10.

La única diferencia entre `include_file` e `import_file` es que el segundo no tira un error cuando no se puede encontrar el archivo.

## Important functions

### `set_forward_no_connect`

Los mensajes solo se envían si ya existe una conexión con el destino. Solo funciona con TCP y TLS. 

Su comportamiento varía dependiendo del bloque de rutas donde se ejecute:

- _`normal request route`_: Afecta stateless forwards y `tm`. Para `tm` afecta todas las branches y posibles retransmisiones.
- _`onreply_route[0] (stateless)`_: Funcionamiento equivalente a `set_reply_*()`. (**Es recomendable utilizar esta última.)**
- _`onreply_route[!=0](tm)`_: No hace nada.
- _`branch_route`_: Afecta solamente el estado de la branch.
- _`onsend_route`_: Comportamiento equivalente a `branch_route`.

```kamailio
route {
  // ...
  if (lookup()) {
    // request to local users. They are usually behind NAT so it does
    // not make sense to establish a new TCP connection.
    set_forward_no_connect();
    t_relay();
  }
  // ...
}
```

### `set_reply_no_connect`

Equivalente a `set_forward_no_connect` pero para respuestas.

Su comportamiento varía dependiendo del bloque de rutas donde se ejecute:

- _`normal request route`_: Afecta todas las respuestas enviadas en la transacción y todas las respuestas stateless (`sl_reply()`).
- _`onreply_route`_: Afecta la respuesta en cuestión. Los `set_flags` configurados en `onreply_route` se usarán.
- _`branch_route`_: No hace nada.
- _`onsend_route`_: No hace nada.

```kamailio
route[4] {
  // request to local users. They are usually behind NAT so it does
  // not make sense to establish a new TCP connection.
  set_reply_no_connect();
  // Do authentication and call routing.
}
```

### `sl_send_reply(code, reason)`

Para el request en proceso, se envía una respuesta con el codigo y la descripción mencionada. La respuesta se envía de forma Stateless, completamente independiente del módulo de transacción y sin retransmisión de respuestas de INVITE.

Si el código esta en el rango 300-399, el destino actual se incluye en el encabezado de `Contact`. 

_Parámetros_

- `code`: Código de respuesta
- `reason`: Mensaje de respuesta

```kamailio
sl_send_reply("404", "Not found");
```

### `maxfwd_process(max_value)`

Si no se detecta un encabezado `Max-Forward`, se agrega uno con un valor igual a `max_value`. Si se encuentra presente, entonces el valor del encabezado se decremente por uno (a menos que su valor sea 0).

_Códigos de respuesta_

- `2 (true)`: Se agrego el encabezado `Max-Forward`.
- `1 (true)`: Se decremento por 1 el valor del encabezado `Max-Forward`.
- `-1 (false)`: Se detecto el valor 0 en el encabezado `Max-Forward`.
- `-2 (false)`: Se produjo un error inesperado.

_Parámetros_

- `max_value`: Valor a agregar en el encabezado `Max-Forward`.

```kamailio
// Intial sanity check -- messages with max_forwards == 0
// or exessively long requests.
if (!maxfwd_process("10") && $retcode == -1) {
  sl_send_reply("403", "Too many hops");
  exit;
}
```

### `mf_process_maxfwd_header(max_value)`

Mismo funcionamiento que `maxfwd_process`.

### `t_check_trans()`

Se utiliza para verificar rápidamente si el mensaje pertenece o esta relacionado a una transacción. Se comporta de diferente manera dependiendo del mensaje.

- Para una respuesta SIP devuelve `true` si el mensaje pertenece a una transacción.
- Para un mensaje tipo `CANCEL` se comporta como `t_lookup_cancel()` (devuelve `true` si existe una transacción de tipo `INVITE` en proceso.)
- Para `ACK` de respuestas negativas o para `ACK` de transacciones locales termina el script.
- Para `ACK` de tipo end-to-end devuelve `true` si existe una transacción de tipo `INVITE` en curso.
- Para otro tipo de requests manda la última respuesta y termina la ejecución de la config.

```kamailio
if (method == "CANCEL" && !t_check_trans()) {
  sl_reply("403", "Cancel out of the blue forbidden");
}
```

**OBS: El uso de `t_check_trans()` puede ser sustituido en este caso por `t_lookup_cancel()`.**

### `t_lookup_cancel([1])`

Devuelve `true` si existe una transacción de tipo `INVITE` en curso cuando llega un `CANCEL` request. Se recomienda que esta función se llame al comienzo del script para identificar si el `CANCEL` puede ser enviado inmediatamente, sin necesidad de entrar en el resto del script.

Si el parámetro opcional se configura en `"1"`, los flags del mensaje se sustituyen por los del `INVITE`. 

```kamailio
if (method == "CANCEL") {
  if (t_lookup_cancel()) {
    log("INVITE transaction exists");
    if (!t_relay_cancel()) { # Implicit drop if relaying was successful, nothing to do.
      # Corresponding INVITE transaction found but error occurred
      sl_reply("500", "Internal Server Error");
      drop;
    }
  }
  # Bad luck. Corresponding INVITE transaction is missing, do the same for INVITEs.
}
```

### `t_relay_cancel()`

Fowardea el `CANCEL` si existe una transacción `INVITE` en curso. Se recomienda su uso al comienzo del script para que los mensajes de tipo `CANCEL` puedan ser capturados antes de ejecutar el resto del mismo.

El valor de respuesta es 

- `0 (drop)`: si se encontro una transacción de tipo `INVITE` y el `CANCEL` se mando correctamente.
- `1 (true)`: si el `INVITE` no se encontro.
- `-1 (false)`: si ocurrio un error.

```kamailio
if (method == "CANCEL") {
  if (!t_relay_cancel()) { # Implicit drop if relaying was successful, nothing to do.
    # Corresponding INVITE transaction found but error occurred.
    sl_reply("500", "Internal Server Error");
    drop;
  }
  # Bad luck. Corresponding INVITE transaction is missing.
  # Do the same for INVITEs.
}
```

### `has_totag()`

Verifica que el encabezado `To` cuente con el parámetro `tag`.

```kamailio
if (has_totag()) {
  // ...
}

**OBS: Importante notar que `t_relay_cancel` incluye `t_lookup_canel` internamente.**

## Python KEMI Interpreter

**Despues de realizar varias pruebas, encontre que el comportamiento de la misma configuración usando KEMI con Python y Native Script no son equivalentes. Esto es, los mismos comandos utilizados en KEMI con Python y en Native Script no se comportan de la misma manera. Esto fue probado en una configuración de unas pocas líneas. La conclusión, fue que KEMI puede utilizarse para realizar acciones adicionales que no se puedan realizar desde Native Script. Todo lo demás, como el manejo de los mensajes, debe realizarse sobre Native Script. Al menos por ahora.**

**OBS: Esta observación es solo valida para el módulo de Python, ya que no se realizarón las mismas pruebas con otros lenguajes.**

Con el fín de exponer lenguajes de scripting más completos que el nativo de Kamailio, se creo el KEMI Interprete. El mismo, permite la carga de ciertos módulos, que permiten escribir la configuración de Kamailio en otros lenguajes de scripting como Python, Lua, Ruby, JavaScript, etc.

Correr la configuración de Kamailio con esta configuración tiene varias ventajas:

1. Se puede hacer uso de las librerías disponibles para cada lenguaje de scripting.
2. Es posible reemplazar la configuración del Kamailio en caliente, sin necesidad de reiniciar el proceso.
3. La posibilidad de utilizar un lenguaje de scripting más completo.

Para utilizar el módulo de Python, es necesario cargar el módulo `app_python3`.

```kamailio
####### Module Load   ########
loadmodule "app_python3.so"

####### Module Configuration #######
modparam("app_python3", "<script_name>", "<path_to_script>)

####### Routing Logic ########
cfgengine "python"
```

Dentro del script the Python se debe declarar la función global `mod_init()`. Esta función instanciara un nuevo objeto que implementará los métodos necesarios para que Kamailio ejecute.

Metodos relevantes:

- `ksr_request_route(self, msg)`: Ejecutada cada vez que se recibe un mensaje SIP. Equivalente a `request_route`.
- `ksr_reply_route(self, msg)`: Ejecutada cada vez que se recibe una respuesta de un mensaje SIP. Equivalente a `reply_route`.
- `ksr_onsend_route(self, msg)`: Ejecutada cada vez que se va a enviar un mensaje, y opcionalmente, cada vez que se quiera enviar una respuesta. Equivalente a `onsend_route`.
- `branch route callback`: Metodo a ejecutar cuando se pasa como argumento a la función `KSR.tm.t_on_branch()`.
- `onreply route callback`: Metodo a ejecutar cuando se pasa como argumento a la función `KSR.tm.t_on_reply()`.
- `failure route callback`: Metodo a ejecutar cuando se pasa como argumento a la función `KSR.tm.t_on_failure`.
- `branch failure route callback`: Metodo a ejecutar cuando se pasa como argumento a la función `KSR.tm.t_on_branch_failure`.

Esta es una configuración base para ejecutar Python como lenguaje de scripting en Kamailio:

```kamailio
####### Global Parameters #########
# Listen LAN
listen = tcp:10.0.2.100:5060

# Listen WAN
listen = tcp:10.0.1.100:5060
listen = udp:10.0.1.100:5060

# TCP
disable_tcp = no
tcp_async = yes
tcp_children = 2

# Alias
#alias="kamailio.example.com:5060"

####### Module Load   ########
loadmodule "tm.so"
loadmodule "tmx.so"
loadmodule "rr.so"
loadmodule "pv.so"
loadmodule "textops.so"
loadmodule "xlog.so"

loadmodule "app_python3.so"

####### Module Configuration #######
modparam("app_python3", "load", "/usr/local/kamailio/kamailio.py")
cfgengine "python"
```

```python
import KSR as KSR

def ksr_info(message):
  KSR.info(f"====== {message} \n")

# Global function to instantiate kamailio class object.
# It is executed when Kamailio app_python module is initialized.
def mod_init():
  ksr_info('From python mod init")
  return Kamailio()

# Kamailio class containing the entire configuration
class Kamailio:
    def __init__(self):
        ksr_info('Kamailio.__init__")

    def child_init(self, rank):
        ksr_info(f'kamailio.child_init({str(rank)})')
        return 0
    
    def ksr_request_route(self, msg):
        ksr_info('Kamailio.ksr_request_route')
```



